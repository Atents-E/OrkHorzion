using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

//#if UNITY_EDITOR
//using UnityEditor;
//#endif

public class EnemyBase : MonoBehaviour
{
    public float moveSpeed = 3.0f;      // 몬스터가 움직이는 속도
    public int monsterHp = 100;         // 몬스터 최대 HP
    public float AttackRadius = 2.3f;   // 몬스터가 공격가능한 범위(반지름)
    public float AttackDemage = 10.0f;  // 몬스터가 공격할때의 데미지
    public float currentAngle = 30.0f;             // 초당 바뀌는 각도
    protected bool looktargetOn = false;           // 몬스터가 플레이어를 바라보는지 
    public float sightHalfAngle = 50.0f;           // 반지름

    protected Transform playerTarget = null;       // 플레이어가 없다
    
    

    //float random;
    //public float Random { get => UnityEngine.Random.Range(0, 1); }      // 어택2용 랜덤값 할당

    public int MonsterHP        // HP 프로퍼티
    {
        get => monsterHp;
        set
        {
            monsterHp = value;

            if (monsterHp < 0)
            {
                monsterHp = 0;

                Die(); // 사망 처리 함수 호출
            }
        }
    }


    void Die()
    {
        looktargetOn = false;
        Destroy(gameObject, 3.0f);  // 3초뒤에 몬스터 오브젝트 삭제    
    }

    protected bool SearchPlayer()
    {
        bool result = false;
        Collider[] colliders = Physics.OverlapSphere(transform.position, AttackRadius, LayerMask.GetMask("Player"));

        if (colliders.Length > 0)
        {
            Vector3 playerPos = colliders[0].transform.position;    // 플레이어의 위치
            Vector3 toPlayerDir = playerPos - transform.position;   // 플레이어로 가는 방향

            // 시야각 안에 플레이어가 있는지 확인
            if (IsInsightAngle(toPlayerDir))
            {
                if (!IsSightBlocked(toPlayerDir))
                {
                    result = true;
                }
            }
        }
        return result;
    }

    protected bool IsInsightAngle(Vector3 toPlayerDir)
    {
        float angle = Vector3.Angle(transform.position, toPlayerDir);   // forward 벡터와 플레이어로 가는 방향 벡터의 사이각 구하기
        return (AttackRadius > angle);
    }

    protected bool IsSightBlocked(Vector3 toPlayerDir)
    {
        bool result = true;

        Ray ray = new(transform.position + transform.up * 0.5f, toPlayerDir);
        if (Physics.Raycast(ray, out RaycastHit hit, AttackRadius))
        {
            if (hit.collider.CompareTag("Player"))
            {
                return result;
            }
        }

        return result;
    }

    protected void Looktarget()
    {
        if (looktargetOn)
        {
            if (playerTarget != null)
            {
                Vector3 dir = (playerTarget.position - transform.position).normalized;
                transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(dir), currentAngle * Time.deltaTime);

            }
        }
    }

//    protected void OnDrawGizmosSelected()
//    {
//#if UNITY_EDITOR
//        Handles.color = Color.red;
//        Handles.DrawWireDisc(transform.position, transform.up, AttackRadius);

//        if (SearchPlayer())
//        {
//            Handles.color = Color.yellow;
//        }
//#endif
//    }


    //void LookTarget()       // 플레이어 방향 바라보기
    //{
    //    if (looktargetOn)
    //    {
    //        if (playerTarget != null)
    //        {
    //            monsterToplayerDir = playerTarget.position - transform.position;
    //            monsterToplayerDir.y = 0;

    //            float betweenAngle = Vector3.SignedAngle(transform.forward, monsterToplayerDir, transform.up);

    //            Vector3 resultDir;

    //            if (Mathf.Abs(betweenAngle) < 10.0f)
    //            {
    //                float rotateDir = 1.0f;

    //                if (betweenAngle < 0)
    //                {
    //                    rotateDir = -1.0f;
    //                }

    //                currentAngle += (rotateDir * turnSpeed * Time.fixedDeltaTime);

    //                resultDir = Quaternion.Euler(0, currentAngle, 0) * transform.forward;
    //            }
    //            else
    //            {
    //                resultDir = monsterToplayerDir;
    //            }
    //            transform.rotation = Quaternion.LookRotation(resultDir);
    //        }

    //    }
    //}
}
